# The Journey to Become a C/C++ Game/Engine Developer

Welcome to my journey in C/C++ game and engine development. This repository serves as a personal log of my progress, learning resources, and projects.

---

## üë§ About Me

Hi, I'm Erkam, an aspiring game developer with a passion for C/C++ and game and engine development. I enjoy learning new technologies and sharing my progress with the community.

---

## üéØ Objective

To document my journey in mastering C/C++ for game and engine development by building hands-on projects, exploring foundational concepts, and honing my skills in both high and low-level game development. This repository aims to serve as a transparent record of my learning process, inspire others who are on similar paths, and encourage feedback and collaboration within the developer community.

---

## Logs

### 2025-07-14

1. You will see that I have put quite a lot of resources (4 at the moment) in learning resources. This is because I've started writing the basics of the game engine. Because of this, I'm constantly reading and implementing from different sources, so the order in which the resources are listed doesn't indicate the order in which they will be completed. In the future I plan to add articles or conferences that I have benefited from.
2. [See why I paused CS:APP](#why-hold)

### 2025-06-27

1. I removed the start date attribute of *Computer Systems: A Programmer's Perspective* and set it to 3rd priority from learning resources, because it doesn't make sense right now to try to read this book binge studying. I need to develop projects to make what is explained in the book more meaningful for me. On the other hand, I don't want to put the book on hold, so I think I will continue little by little as I have time from other learning resources and projects I have developed.

### 2025-02-13

1. While studying *The C Programming Language by Kernighan and Ritchie*, I realized that the book is more of a documentation of C itself rather than a teaching guide for beginners. Although I learned some valuable things, I didn‚Äôt feel like my overall familiarity with C improved significantly. Additionally, I found the exercises quite challenging, especially in the last three chapters. Therefore, I‚Äôve decided not to continue with the remaining chapters and instead start C Programming: A Modern Approach by K. N. King, as I‚Äôve heard it's better suited for learning C in a more comprehensive and beginner-friendly manner. My goal is to complete this book to solidify my understanding of C before moving on to more advanced topics.

### 2025-01-24

1. I decided to read Computer Systems: A Programmer's Perspective after reading and finishing The C Programming Language, because I thought I would need a relatively good knowledge of C programming to do the exercises in it, and the authors of Computer Systems: A Programmer's Perspective also recommends The C Programming Language for learning C programming.
2. Also, while I am currently working on a project called *Gate Survivors*, I wanted to take the time to learn only one subject in depth. The subject I decided to learn in depth for now is computer systems and low level programming. So I decided to stop reading the *3D Math Primer for Graphics and Game Development* for now and continue reading it after I finished reading *Computer Systems: A Programmer's Perspective*.

---

## üîú TODO

### üìù Projects

- [ ] 3D DirectX Game

### üìö Learning Resources

- [ ] [Game Coding Complete](https://www.mcshaffry.com/GameCode/)

---

## üîõ In Progress

### üìù Projects

#### üê¶‚Äçüî• Primordial Game Engine

**Technologies Used:** C, C++</br>
**Status:** Ongoing</br>
This is a 3D game engine that I plan to implement using all the knowledge I have learned. This is the project I will do the most work on over time. This explanation will be elaborated.

#### Gate Survivors</br>

**Technologies Used:** Unity, C#, HLSL, ECS</br>
**Status:** Ongoing</br>
This is a game built on the Unity game engine that I know, using an entity component system that I wrote myself. Thanks to this system, physics calculations, rendering and animation calculations of a very large number of entities can be done efficiently and quickly. Also, this project gives me the opportunity to showcase my skills in C# and Unity and gain experience by publishing a game and observing the post-launch process.

### üìö Learning Resources

#### 1. [3D Math Primer for Graphics and Game Development](https://gamemath.com/) by Fletcher Dunn

**Start Date:** 2025-06-27</br>
**Status:** Ongoing</br>
**Repo  :** This is a private repo at the moment.

##### Chapters

- [x] 1. Cartesian Coordinate Systems 
- [x] 2. Vectors 
- [x] 3. Multiple Coordinate Spaces 
- [x] 4. Introduction to Matrices 
- [x] 5. Matrices and Linear Transformations 
- [x] 6. More on Matrices 
- [x] 7. Polar Coordinate Systems 
- [x] 8. Rotation in Three Dimensions 
- [x] 9. Geometric Primitives 
- [x] 10. Mathematical Topics from 3D Graphics 
- [ ] 11. Mechanics 1: Linear Kinematics and Calculus 
- [ ] 12. Mechanics 2: Linear and Rotational Dynamics 
- [ ] 13. Curves in 3D 
- [ ] 14. Afterword 

#### 2. [DirectX 11 Tutorials from RasterTek](https://www.rastertek.com/tutdx11win10.html) by RasterTek

**Start Date:** 2025-07-11</br>
**Status:** Ongoing</br>
**Repo  :** This is a private repo at the moment.

##### Chapters

- [x] 1. Setting up DirectX 11 with Visual Studio 2022
- [x] 2. Creating a Framework and Window
- [x] 3. Initializing DirectX 11
- [x] 4. Buffers, Shaders, and HLSL
- [x] 5. Texturing
- [x] 6. Diffuse Lighting
- [x] 7. 3D Model Rendering
- [x] 8. Scaling, Rotation, and Translation
- [x] 9. Ambient Lighting
- [x] 10. Specular Lighting
- [x] 11. Multiple Point Lights
- [x] 12. 2D Rendering
- [x] 13. Sprites and Timers
- [x] 14. Font Engine
- [x] 15. FPS Counters
- [x] 16. Direct Input
- [x] 17. Multitexturing
- [x] 18. Light Maps
- [x] 19. Alpha Mapping
- [x] 20. Normal Mapping
- [x] 21. Specular Mapping
- [x] 22. Managing Multiple Shaders
- [x] 23. Frustum Culling
- [x] 24. Loading Maya Models
- [x] 25. Render to Texture
- [x] 26. Fog
- [x] 27. Clipping Planes
- [ ] 28. Texture Translation
- [ ] 29. Transparency
- [ ] 30. Reflection
- [ ] 31. Water
- [ ] 32. Glass and Ice
- [ ] 33. Fire
- [ ] 34. Billboarding
- [ ] 35. Depth Buffer
- [ ] 36. Blur
- [ ] 37. Screen Fades
- [ ] 38. Particle Systems
- [ ] 39. Projective Texturing
- [ ] 40. Projected Light Maps
- [ ] 41. Shadow Mapping
- [ ] 42. Multiple Light Shadow Mapping
- [ ] 43. Directional Shadow Maps
- [ ] 44. Soft Shadows
- [ ] 45. Shadow Mapping and Transparency
- [ ] 46. Glow
- [ ] 47. Picking
- [ ] 48. Instancing
- [ ] 49. Hardware Tessellation
- [ ] 50. Deferred Shading
- [ ] 51. Screen Space Ambient Occlusion
- [ ] 52. Physically Based Rendering
- [ ] 53. Heat
- [ ] 54. Parallax Scrolling
- [ ] 55. Direct Sound
- [ ] 56. 3D Sound
- [ ] 57. XAudio2
- [ ] 58. X3DAudio
- [ ] 59. Animated Particles
- [ ] 60. XInput

#### 3. [Introduction to 3D Game Programming with Direct3D 11.0](https://d3dcoder.net/d3d11.htm) by Frank D. Luna

**Start Date:** 2025-07-14</br>
**Status:** Ongoing</br>
**Repo  :** This is a private repo at the moment.

- [ ] 1. Vector Algebra
- [ ] 2. Matrix Algebra
- [ ] 3. Transformations
- [ ] 4. Direct3D Initialization
- [ ] 5. The Rendering Pipeline
- [ ] 6. Drawing in Direct3D
- [ ] 7. Lighting
- [ ] 8. Texturing
- [ ] 9. Blending
- [ ] 10. Stenciling
- [ ] 11. The Geometry Shader
- [ ] 12. The Compute Shader
- [ ] 13. The Tessellation Stages
- [ ] 14. Building a First Person Camera ,
- [ ] 15. Instancing and Frustum Culling
- [ ] 16. Picking
- [ ] 17. Cube Mapping
- [ ] 18. Normal Mapping and Displacement Mapping ‚Ä¶..
- [ ] 19. Terrain Rendering
- [ ] 20. Particle Systems and Stream-Out
- [ ] 21. Shadow Mapping
- [ ] 22. Ambient Occlusion
- [ ] 23. Meshes
- [ ] 24. Quaternions
- [ ] 25. Character Animation

#### 4. [Game Engine Architecture](https://www.gameenginebook.com//) by Jason Gregory

**Start Date:** 2025-07-14</br>
**Status:** Ongoing</br>
**Repo  :** This is a private repo at the moment.

##### Chapters

- [ ] 1. Introduction
- [ ] 2. Tools of the Trade
- [ ] 3. Fundamentals of Software Engineering for Games
- [ ] 4. Parallelism and Concurrent Programming
- [ ] 5. 3D Math for Games
- [ ] 6. Engine Support Systems
- [ ] 7. Resources and the File System
- [ ] 8. The Game Loop and Real-Time Simulation
- [ ] 9. Human Interface Devices (HID)
- [ ] 10. Tools for Debugging and Development
- [ ] 11. The Rendering Engine
- [ ] 12. Animation Systems
- [ ] 13. Collision and Rigid Body Dynamics
- [ ] 14. Audio
- [ ] 15. Introduction to Gameplay Systems
- [ ] 16. Runtime Gameplay Foundation Systems
- [ ] 17. You Mean There‚Äôs More?

---

## ‚úîÔ∏è Done

### üìö Learning Resources

> Descending order

#### 3. [C++ Primer, 5th Edition](https://cpp-primer.pages.dev/) by Stanley B. Lippman.

**Start Date:** 2025-04-02</br>
**End Date:** 2025-06-27</br>
**Completion Time:** ~160 Hours</br>
**Status:** Done</br>
**Repo:** [My Solutions to the C++ Primer, 5th Edition](https://github.com/erkamuzuncayir/cpp-primer)

##### My Takeaways from C Programming: A Modern Approach in a Nutshell

Surprisingly, this is the second book I study to learn C++. I first tried Bjarne Stroustrup's *Programming: Principles and Practice Using C++* because after all he is the creator of C++. But when I started reading it, I realized that this book was not designed to teach me C++, but to teach me the basics of programming without going too deep into C++. 
So I put that book down and started this book, which is the other most recommended book for learning C++. I usually look at what the authors have done before I read a book, and when I saw that Stanley B. Lippmann is one of the developers of the *Gamebyro Game Engine*, I was even more eager to study this book.

All in all, another excellent book. With detailed explanations, exercises and a defined terms section (this is one of the parts that really helps you understand what something is in terms of definition), it covers all the basic details of C++ and the author covers everything he thinks is important.

I'm glad that I picked up this book instead of continuing with *Programming: Principles and Practice Using C++*. I wholeheartedly recommend this book to anyone who wants to learn the C++ programming language.

Finally, I should mention here that K. N. King's *C Programming: A Modern Approach*, as a textbook, teaches better than this book. However, I'm not sure how much of this is the work of the authors and how much is the difference made by the programming languages taught.  I have to admit that in the end I liked C much more than C++.

---

#### 2. [C Programming: A Modern Approach](http://knking.com/books/c2/) by K. N. King.

**Start Date:** 2025-02-13</br>
**End Date:** 2025-03-28</br>
**Completion Time:** ~120 Hours</br>
**Status:** Done</br>
**Repo:** [My Solutions to the C Programming: A Modern Approach](https://github.com/erkamuzuncayir/c-programming-a-modern-approach)

##### My Takeaways from C Programming: A Modern Approach in a Nutshell

This is the second book I‚Äôve read to learn C by solving problems. I first tried *The C Programming Language* by Brian W. Kernighan and Dennis M. Ritchie because this book is considered the go-to for all things C. However, when I reached the middle of the book, I realized that, as someone still unfamiliar with C, I wasn't able to learn much from it. 

When I started reading *C Programming: A Modern Approach*, I realized that *The C Programming Language* was not designed to teach me C. It‚Äôs simply a reference book, whereas *C Programming: A Modern Approach* is an excellent textbook. With its detailed explanations, exercises, programming projects, and especially the Q&A section, which offers a level of detail I haven't seen in other textbooks, it covers all the essential details of C, a language that is both simple and powerful, and addresses everything it believes to be important. 

I‚Äôm glad I switched to this book instead of continuing with *The C Programming Language*. I **highly** recommend this book to anyone wanting to learn the C programming language.

---

#### 1. [Introduction to Computing Systems: From Bits & Gates to C/C++ & Beyond](https://www.mheducation.com/highered/product/introduction-computing-systems-bits-gates-c-c-beyond-patt-patel/M9781260150537.html)

**Start Date:** 2024-10-12</br>
**End Date:** 2025-01-24</br>
**Completion Time:** ~150 Hours</br>
**Status:** Done</br>
**Repo:** [My Solutions of Introduction to Computing Systems](https://github.com/erkamuzuncayir/solutions-of-introduction-to-computing-systems)

##### My Takeaways from Introduction to Computing Systems: From Bits & Gates to C/C++ & Beyond

###### 1. Understanding the Big Picture
This book excels in showing the connection between the lowest-level hardware components and high-level programming languages, bridging the gap in a way that's both engaging and thorough. However, it‚Äôs important to note that the C and C++ lessons provided in the book are not sufficient to master these languages on their own. They serve more as a foundation for understanding how these languages operate closer to the hardware.

###### 2. Assembly Language and Low-Level Programming
Writing assembly was genuinely challenging, yet immensely rewarding. It provided a unique opportunity to see how things work at the most fundamental level, giving me a deeper understanding of how code gets executed by the CPU. Tasks such as managing memory manually, handling registers, and writing loops or conditionals in assembly helped me truly grasp concepts like bitwise operations, recursion, and iteration, and how these abstractions actually function under the hood. Seeing the advantages and disadvantages of these concepts from a low-level perspective was invaluable.

###### 3. Memory Systems and Emergence of Complexity
The book effectively demonstrates how simple and small components, like logic gates, come together to form complex systems‚Äîthis concept, often referred to as emergence, was incredibly eye-opening. It‚Äôs fascinating to see how individual bits and operations combine to create something as versatile as a programming language or even a full-fledged operating system. It reminded me of how non-living atoms form living organisms.

###### 4. Problem-Solving and Practical Learning
The book does an excellent job of teaching fundamental programming concepts, such as recursion, iteration, and data manipulation, while also showing how and why these concepts work. By requiring readers to write them at the assembly level, it provides an appreciation for their elegance and power. Additionally, the step-by-step progression from simple circuits to complete systems effectively illustrates the incremental problem-solving approach required for tackling complex challenges.

###### 5. Programming Perspectives
What I particularly liked is how the book reframes the way you think about programming:

  - It‚Äôs no longer just about "writing code," but understanding why certain design choices are made and how they impact the underlying hardware.
  - Although the book isn‚Äôt intended for this purpose, it made me wish it included more real-world examples of programming design trade-offs and how these decisions manifest in low-level advantages or disadvantages. Such an addition would have tied its low-level explanations more explicitly to everyday programming challenges.

###### 6. Challenges and Growth
The steep learning curve‚Äîespecially while writing in assembly‚Äîwas both frustrating and rewarding. The challenge paid off by giving me a clearer understanding of the low-level operations and their connections to higher-level abstractions. Even though assembly was tough, the experience was invaluable and felt like a rite of passage for anyone interested in understanding computers at their core.

###### 7. Future Applications
This book has laid a strong foundation for my journey in game and engine development with C/C++. Many of the concepts I learned, such as memory management and low-level programming, are directly applicable to building efficient and performant systems. Understanding how abstractions are built on top of hardware processes will help me make more informed decisions when working with tools like OpenGL or Vulkan.

In conclusion, Introduction to Computing Systems is an excellent resource for anyone who wants to dive deep into computer systems and see how they function from the ground up. While the C and C++ lessons are not enough to fully learn the languages, the perspective this book provides will forever change how you approach programming and problem-solving. I highly recommend it, especially if you‚Äôre passionate about understanding the inner workings of computers and want to become a more deliberate programmer.

---

## üõë Hold / Cancel

### üìö Learning Resources

#### 1. [The C Programming Language](https://www.goodreads.com/book/show/515601.The_C_Programming_Language) by Brian W. Kernighan and Dennis M. Ritchie

**Start Date:** 2025-01-24</br>
**Hold Date:** 2025-02-13</br>
**Status:** Hold</br>
**Progression:** 65%</br>
**Study Time:** ~50 Hours</br>
**Repo:** [My Solutions of The C Programming Language](https://github.com/erkamuzuncayir/the-c-programming-language)

##### Why hold?

While studying The C Programming Language by Kernighan and Ritchie, I realized that the book is more of a documentation of C itself rather than a teaching guide for beginners. Although I learned some valuable things, I didn‚Äôt feel like my overall familiarity with C improved significantly. Additionally, I found the exercises quite challenging, especially in the last three chapters.

Therefore, I‚Äôve decided not to continue with the remaining chapters and instead start C Programming: A Modern Approach by K. N. King, as I‚Äôve heard it's better suited for learning C in a more comprehensive and beginner-friendly manner. My goal is to complete this book to solidify my understanding of C before moving on to more advanced topics.

2. #### [Computer Systems: A Programmer's Perspective, Third Edition](https://csapp.cs.cmu.edu/) by Randal E. Bryant and David R. O'Hallaron.

**Status:** Hold</br>
**Repo  :** [My Solutions to the Computer Systems: A Programmer's Perspective, Third Edition](https://github.com/erkamuzuncayir/computer-systems-a-programmers-perspective)

##### Why hold?

As far as I can see from the questions I have read and solved so far from this book, it will be useful for me to read this book by really understanding it and solving all the questions. But this may take a little longer. On the other hand, I think it would be more suitable for my purpose to put something practical into practice right now. For this reason, I put the book on hold.

---

## ü§ù Contributions & Feedback

I welcome suggestions for resources, projects, or improvements to this repository. If you find any mistakes, have ideas, or want to contribute, feel free to reach out, open an issue, or submit a pull request!

---

## üì´ Contact

You can reach me via [e-mail](mailto:erkamuzuncayir@gmail.com) or connect with me on [LinkedIn](https://www.linkedin.com/in/erkamuzuncayir/).
